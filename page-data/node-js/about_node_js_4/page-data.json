{"componentChunkName":"component---src-template-post-tsx","path":"/node-js/about_node_js_4/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://akasai.space","comment":{"giscus":"akasai/akasai.github.io","repo_id":"MDEwOlJlcG9zaXRvcnkyOTMzMTQ4NzA=","category_id":"DIC_kwDOEXuhNs4CAnjz"}}},"post":{"id":"119743d2-cfe8-58b6-9f13-4d4f49c78cbd","excerpt":"앞서서 Node.js의 비동기처리에 대한 전반적인 내용을 정리했다. 이번엔 싱글만레드의 특징을 정리하려 한다. + 정말… 해도해도 공부할 내용이 끝이 없다. 얼마나 대충쓰고 있었는지 반성한다… 싱글 스레드 (Single…","timeToRead":3,"html":"<p>앞서서 Node.js의 비동기처리에 대한 전반적인 내용을 정리했다.</p>\n<p>이번엔 싱글만레드의 특징을 정리하려 한다.</p>\n<p><em>+ 정말… 해도해도 공부할 내용이 끝이 없다. 얼마나 대충쓰고 있었는지 반성한다…</em></p>\n<hr>\n<h2 id=\"싱글-스레드-single-thread\" style=\"position:relative;\"><a href=\"#%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C-single-thread\" aria-label=\"싱글 스레드 single thread permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>싱글 스레드 (Single Thread)</h2>\n<p><strong>싱글 스레드(Single Thread)</strong> 란 말 그대로 하나의 스레드만을 사용하여 여러 작업요청을 처리하는 방법이다.</p>\n<p>앞서 정리한 것처럼 <code class=\"language-text\">I/O</code>작업과 같은 경우 비동기방식으로 처리하고</p>\n<p>그 동안 다른 작업을 처리하는 방식이다.</p>\n<p><span class=\"em red\">한개의 콜스택으로 명령을 처리하는 Node.js</span>는 이런면에서 <code class=\"language-text\">싱글 스레드</code>라고 할 수 있다.</p>\n<p>그렇다면 Node.js는 항상 <strong>싱글 스레드</strong>방식으로 동작할까??</p>\n<p>정답은 <span class=\"em red\">아니다.</span></p>\n<hr>\n<h2 id=\"스레드-풀-thread-pool\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%92%80-thread-pool\" aria-label=\"스레드 풀 thread pool permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드 풀 (Thread pool)</h2>\n<p><strong>멀티 스레드(Multi Thread)</strong> 모델의 경우 <code class=\"language-text\">스레드 풀</code>을 두고 요청을 처리할 때 스레드를 기반으로 처리한다.</p>\n<p>앞서 정리한 것 처럼 대부분의 작업은 콜스택을 통해 처리되며 Queue를 이용해 비동기 작업을 처리하지만</p>\n<p><strong>I/O, 네트워크</strong>등의 작업은 OS에게 작업은 넘겨주는 <code class=\"language-text\">논블로킹</code>방식으로 동작한다.</p>\n<p>하지만, OS에서 지원하지 않는 비동기작업이나 특정 I/O작업은 <strong>libuv</strong>에서 처리하게되며 이는 내부적으로 운영되는</p>\n<p><code class=\"language-text\">스레드 풀</code>을 이용하여 논블로킹을 유지한다.</p>\n<p>이러한 이유로 <strong>단일 콜스택</strong>측면에서는 <code class=\"language-text\">싱글 스레드</code>이지만 넓은 측면에서 본다면 무조건 싱글스레드는 아니라고 볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 49%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgABBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe6VoZR//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGhAAAgMBAQAAAAAAAAAAAAAAAAERQYEQMf/aAAgBAQABPyGhuLjDRed//9oADAMBAAIAAwAAABBzD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAAICAgMAAAAAAAAAAAAAAAABESFBUTFxkf/aAAgBAQABPxCHtnJHu1q7Sxq3Tw5u2aGlpH//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"libuv\"\n        title=\"libuv\"\n        src=\"/static/45427dcce42d7cfd5d1e12c45003839f/e5166/libuv.jpg\"\n        srcset=\"/static/45427dcce42d7cfd5d1e12c45003839f/f93b5/libuv.jpg 300w,\n/static/45427dcce42d7cfd5d1e12c45003839f/b4294/libuv.jpg 600w,\n/static/45427dcce42d7cfd5d1e12c45003839f/e5166/libuv.jpg 1200w,\n/static/45427dcce42d7cfd5d1e12c45003839f/b6e58/libuv.jpg 1430w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<hr>\n<h2 id=\"스택-오버플로우-stack-overflow\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D-%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C%EC%9A%B0-stack-overflow\" aria-label=\"스택 오버플로우 stack overflow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택 오버플로우 (Stack Overflow)</h2>\n<p>Javascript는 작업 수행도중 에러가 발생하면 <code class=\"language-text\">Stack trace</code>라는 내용을 확인할 수 있다.</p>\n<p>모든 작업이 하나의 콜스택에서 이루어지기 때문에 알 수 있는 특징이다.</p>\n<p><strong>스택</strong>이라는 용어에서 추측할 수 있듯이 에러나가 발생하기전 처리되었던 내용들이 <code class=\"language-text\">Stack trace</code>를 통해 확인할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwklEQVQoz12Q2W7TQBSG/SyUxrN4S+yMPWMn8b6M7fGerW24AK5QaR8AQSXeg2dFSWgFSJ90/rPpHP0SwjY0qD5fYZVekRFBiGBkqyrVVKoq1NBcU/fm85VueBARiOwrkrdK+bgbxgfP55QlzE0dFpsKqxn/cXr6dv/4/f7xszg1YWto7N1sAc7Lf5AWi7Vl+nPdXRubPunHZNjHY0AzgIh2vsx0lQFEZrIJEWHLQFPpLbAAIgARyXPiIhRF1BSh4GmbxQ3P+pqPQVA5TuTakUuileJRzBAkX8aPLx+eM4/fyCbEtoQ0mqedELuSD0XalvXUTw/9eN/2d8N0app9VU6OHWFIMCBYcSxzY1s+VJwZXEqq7or2UFXbpj2U1VSJnWj2TXtsu2Pb3zXdsW72cdGvrTAnqa6yr8OnX88/X05PjhlIisbyYhDtgdfbNO+qeluLHa+mst6W9fYiJuJEquFiw8UapWYQ0WxNYkWhkqaztV8GUZXzPozrKBEbnydZl/MhTrsoEUnW+mG13nCsODJc3gLrRjbfA1M+v41tpDhX9yC2Ibbf9N/in9aFs9vyJQBEZLgEkMjwLSUAvtZfZ/7jN9VzjiwuWYrhAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"error\"\n        title=\"error\"\n        src=\"/static/0ded75396cf36968b5661e8c246375db/c1b63/error.png\"\n        srcset=\"/static/0ded75396cf36968b5661e8c246375db/5a46d/error.png 300w,\n/static/0ded75396cf36968b5661e8c246375db/0a47e/error.png 600w,\n/static/0ded75396cf36968b5661e8c246375db/c1b63/error.png 1200w,\n/static/0ded75396cf36968b5661e8c246375db/d61c2/error.png 1800w,\n/static/0ded75396cf36968b5661e8c246375db/2b36a/error.png 2268w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><span class=\"em red\">여기서 주의할 점은 콜스택도 경국 유한한 구조라는 점이다.</span></p>\n<p>명령들이 반환되지 않을 상태로 콜스택에 계속 쌓이게 되면 결국 넘치게 되고</p>\n<p><code class=\"language-text\">Maximum call stack size exceeded</code> 에러를 뿌린다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 786px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABNUlEQVQoz4WNi26DMAwA+f+Pq9pC2NStg5EHlGDHCaSi7RpPdJv2krbTyZItnZwppUII3nsiQkQppTFGKVXXtbnhnAtfGD8IIWRVVTWNVEoBgL/hnCMiAIgxnk6n+TvW2r7vrbXjOGbp+hK8n8aJf5FS4h8yO+fssDDPc3aAIHV7sPZyvS7BnzJz13WNlErreDxm7Xo3Vc28fzpXz8m0F9Oybrm33B2W2VvWhh1xPPIUeYqoFEhp6+cZMEtI3Fu/2dbbrcwLXQgekAF5ALYDW1j6ARjdmxc7vJmWmDyjO+fCrdYmL+pC9Pun0MgrIJN/19GnX47ZsgNyUabVJm5yJcR+vdGijFL/zH6ZJUeMNIo7KUSVF7IsGSER8Rj+Lm+fyZ+7Qy9Ks3vwTaPvH51CUogN/Bu/AoogMw37MppMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"trace\"\n        title=\"trace\"\n        src=\"/static/0d3caaea507159161688e9b0c6e396c0/321ea/trace.png\"\n        srcset=\"/static/0d3caaea507159161688e9b0c6e396c0/5a46d/trace.png 300w,\n/static/0d3caaea507159161688e9b0c6e396c0/0a47e/trace.png 600w,\n/static/0d3caaea507159161688e9b0c6e396c0/321ea/trace.png 786w\"\n        sizes=\"(max-width: 786px) 100vw, 786px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<hr>\n<h2 id=\"이벤트-루프-멀티플랙싱multiplexing\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EB%A9%80%ED%8B%B0%ED%94%8C%EB%9E%99%EC%8B%B1multiplexing\" aria-label=\"이벤트 루프 멀티플랙싱multiplexing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이벤트 루프 멀티플랙싱(Multiplexing)</h2>\n<p>Node.js는 <code class=\"language-text\">싱글 스레드</code>라는 내용은 자주 언급된다.</p>\n<p>많은 수의 작업이 요청되는 경우 (<em>예를 들면 API호출</em>) 이를 어떻게 처리할 것인지 의문이 발생한다.</p>\n<p>바로 이벤트 루프의 <code class=\"language-text\">멀티 플렉싱(Multiplexing)</code>에서 그 답을 찾을 수 있다.</p>\n<h3 id=\"멀티플렉싱multiplexing\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1multiplexing\" aria-label=\"멀티플렉싱multiplexing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티플렉싱(Multiplexing)</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB2Y3iIQv/xAAYEAEAAwEAAAAAAAAAAAAAAAABAAIxIf/aAAgBAQABBQJUt2Vxjk//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAACAwAAAAAAAAAAAAAAAAAAASAxcf/aAAgBAQAGPwJ4XH//xAAZEAADAQEBAAAAAAAAAAAAAAAAARExIYH/2gAIAQEAAT8hkHgrpu7OGN0RPUaCZ//aAAwDAQACAAMAAAAQlw//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxAn/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EE2f/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARITFBkf/aAAgBAQABPxC0q4Tqm+zkpwqhfSJXCI0X2CWC80mKsoyMnX7P/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"multiplex\"\n        title=\"multiplex\"\n        src=\"/static/53b8b25fc8f86506a515464d8936c35f/e5166/multiplex.jpg\"\n        srcset=\"/static/53b8b25fc8f86506a515464d8936c35f/f93b5/multiplex.jpg 300w,\n/static/53b8b25fc8f86506a515464d8936c35f/b4294/multiplex.jpg 600w,\n/static/53b8b25fc8f86506a515464d8936c35f/e5166/multiplex.jpg 1200w,\n/static/53b8b25fc8f86506a515464d8936c35f/d165a/multiplex.jpg 1400w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><code class=\"language-text\">멀티플렉싱(Multiplexing)</code>이란 하나의 통신채널을 통해 다량의 데이터를 전송하는데 사용되는 기술이다.</p>\n<p>즉, 매 요청마다 새로운 프로세스나 스레드를 생성하는 것이 아니라 <span class=\"em red\">요청의 갯수와 상관없이 한개의 프로세스나 스레드를 이용</span>하여 작업을 처리하는 방법이다.</p>\n<p>주파수 분할, 시분할 등을 예로 들 수 있다.</p>\n<h3 id=\"nodejs의-경우\" style=\"position:relative;\"><a href=\"#nodejs%EC%9D%98-%EA%B2%BD%EC%9A%B0\" aria-label=\"nodejs의 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js의 경우</h3>\n<p>Node.js의 모든 작업처리는 <strong>단일 콜스택</strong>에서 이루어지고 비동기 처리는 <strong>Queue</strong>를 이용하며 둘은 하나의 쓰레드로 이루어진 <strong>이벤트 루프</strong>를 통해 동작한다.</p>\n<p><strong>이벤트 루프</strong>는 <code class=\"language-text\">멀티플렉싱(Multiplexing)</code>방식으로 동작한다. 여러 개의 소켓이 동시에 연결되어 있고, 이들을 관찰하면서\n들어오는 작업을 처리하는 방식이다.</p>\n<p>기존의 웹서버의 경우엔 요청이 들어오면 이를 처리하기위한 프로세스나 쓰레드를 생성하는데 이를 대기하는 시간이 발생하고 (Thread waiting)이 과정에서 병목현상이 발생한다.</p>\n<p>하지만 Node.js의 경우에는 다량의 작업이 요청되어도 쓰레드대기가 발생하지 않고 작업의 처리는 다른 쓰레드로 넘겨버리기 때문에 바로 다른 작업 요청을 받을 수 있다.</p>\n<p><span class=\"callout\">위 방식이 만능은 아니다. CPU의 영향을 많이 받는 요청의 경우 한정된 쓰레드에서 I/O 작업이 처리되며 이를 이벤트루프는 대기하기 때문에 이후 발생하는 다른 Request들에 병목현상이 발생한다.</span></p>\n<hr>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li>\n<p><a href=\"https://sjh836.tistory.com/79\">Node.js의 기초(내부 아키텍처, 이벤트루프와 워커, 비동기의 이해)</a></p>\n</li>\n<li>\n<p><a href=\"https://bcho.tistory.com/881\">빠르게 훝어보는 node.js</a></p>\n</li>\n<li>\n<p><a href=\"https://ggoals.tistory.com/63\">Node.js 란</a></p>\n</li>\n</ul>","fields":{"slug":"/node-js/about_node_js_4/"},"frontmatter":{"title":"Node.js의 스레드","series_num":4,"date":"Oct 13. 2020","tags":["Node.js","Javascript","V8","Single Thread","싱글스레드"]},"headings":[{"value":"싱글 스레드 (Single Thread)","depth":2,"id":"싱글-스레드-single-thread"},{"value":"스레드 풀 (Thread pool)","depth":2,"id":"스레드-풀-thread-pool"},{"value":"스택 오버플로우 (Stack Overflow)","depth":2,"id":"스택-오버플로우-stack-overflow"},{"value":"이벤트 루프 멀티플랙싱(Multiplexing)","depth":2,"id":"이벤트-루프-멀티플랙싱multiplexing"},{"value":"멀티플렉싱(Multiplexing)","depth":3,"id":"멀티플렉싱multiplexing"},{"value":"Node.js의 경우","depth":3,"id":"nodejs의-경우"},{"value":"Reference","depth":2,"id":"reference"}]},"related":{"nodes":[{"fields":{"slug":"/node-js/about_node_js_1/"},"frontmatter":{"title":"Node.js의 구조","date":"Oct 06. 2020"}},{"fields":{"slug":"/node-js/about_node_js_2/"},"frontmatter":{"title":"Node.js의 이벤트 루프와 비동기","date":"Oct 08. 2020"}},{"fields":{"slug":"/node-js/about_node_js_3/"},"frontmatter":{"title":"비동기와 논블로킹","date":"Oct 12. 2020"}},{"fields":{"slug":"/node-js/about_node_js_package_top10/"},"frontmatter":{"title":"2020 TOP 10 Node.js Package & Framework","date":"Oct 12. 2020"}},{"fields":{"slug":"/node-js/about_promise_allsettled/"},"frontmatter":{"title":"Promise.allSettled()","date":"Dec 08. 2021"}},{"fields":{"slug":"/node-js/solving_promise_bottleneck/"},"frontmatter":{"title":"async/await 병목현상 줄여보기","date":"Sep 21. 2020"}},{"fields":{"slug":"/node-js/about_node_js_5/"},"frontmatter":{"title":"Node.js의 I/O 동작","date":"Oct 21. 2020"}}]}},"pageContext":{"id":"119743d2-cfe8-58b6-9f13-4d4f49c78cbd","slug":"/node-js/about_node_js_4/","series_name":"Node.js 파헤치기","category":"Node.js","previous":{"fields":{"slug":"/node-js/about_node_js_3/"},"frontmatter":{"title":"비동기와 논블로킹"}},"next":{"fields":{"slug":"/etc/about_roadmap_2020/"},"frontmatter":{"title":"개발자 로드맵"}}}},"staticQueryHashes":["1069093791","1381152472","1821008744","278901532","3528274121"]}