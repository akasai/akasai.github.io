{"componentChunkName":"component---src-template-post-tsx","path":"/typescript/typescript_solid_1/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://akasai.space","comment":{"giscus":"akasai/akasai.github.io","repo_id":"MDEwOlJlcG9zaXRvcnkyOTMzMTQ4NzA=","category_id":"DIC_kwDOEXuhNs4CAnjz"}}},"post":{"id":"50684170-013f-52f1-87fa-b247c01d6567","excerpt":"OOP 란? OOP…","timeToRead":3,"html":"<h2 id=\"oop-란\" style=\"position:relative;\"><a href=\"#oop-%EB%9E%80\" aria-label=\"oop 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OOP 란?</h2>\n<h3 id=\"oop-가-뭐길래\" style=\"position:relative;\"><a href=\"#oop-%EA%B0%80-%EB%AD%90%EA%B8%B8%EB%9E%98\" aria-label=\"oop 가 뭐길래 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OOP 가 뭐길래?</h3>\n<p>프로그래밍에서 필요한 <strong>데이터</strong>를 <span class=\"em red\">추상화</span>시켜 상태와 행위를 가진 <strong>객체</strong>를 만들고 그 객체들 간의 <span class=\"em red\">유기적인 상호작용</span>을 통해 로직을 구성하는 프로그래밍 방법이다.</p>\n<h3 id=\"왜-좋은데\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%A2%8B%EC%9D%80%EB%8D%B0\" aria-label=\"왜 좋은데 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 좋은데?</h3>\n<ol>\n<li>\n<p>코드 재사용이 용이</p>\n<p>존재하는 클래스를 가져와서 이용할 수 있고 <span class=\"em red\">상속</span>을 통해 <strong>확장</strong>해서 사용할 수 있다.</p>\n</li>\n<li>\n<p>유지보수가 쉬움</p>\n<p>절차 지향 프로그래밍에서는 코드를 수정 시 일일이 찾아 수정 해야한다. 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면 된다.</p>\n</li>\n<li>\n<p>대형 프로젝트에 적합</p>\n<p>클래스단위로 <strong>모듈화</strong>시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.</p>\n</li>\n</ol>\n<h3 id=\"좋은-점만-있을까\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-%EC%A0%90%EB%A7%8C-%EC%9E%88%EC%9D%84%EA%B9%8C\" aria-label=\"좋은 점만 있을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 점만 있을까?</h3>\n<ol>\n<li>\n<p><strong>처리속도</strong>가 상대적으로 느리다.</p>\n</li>\n<li>\n<p>객체가 많으면 <strong>용량</strong>이 커질 수 있다.</p>\n</li>\n<li>\n<p><strong>설계</strong>시 많은 시간과 노력이 필요하다.</p>\n</li>\n</ol>\n<h3 id=\"핵심-키워드\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC-%ED%82%A4%EC%9B%8C%EB%93%9C\" aria-label=\"핵심 키워드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심 키워드</h3>\n<ol>\n<li>\n<p>클래스 + 인스턴스(객체)</p>\n<p><span class=\"em red\">클래스</span></p>\n<p>문제해결을 위한 데이터를 만들기 위해 <strong>추상화</strong>를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 <strong>변수</strong>와 <strong>메서드</strong>로 정의한 것이다.</p>\n<p><span class=\"em red\">인스턴스</span></p>\n<p>클래스에서 정의한 것을 토대로 <strong>실제 메모리상에 할당된 것</strong>으로 실제 프로그램에서 사용되는 데이터이다.</p>\n</li>\n<li>\n<p>추상화</p>\n<p>불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 행위를 묶어 이름을 붙이는 것이다. 객체지향 관점에서는 <strong>클래스를 정의하는 것</strong> 자체를 추상화로 본다.</p>\n<p><em>단, <strong><code class=\"language-text\">abstract</code></strong> 클래스, <strong><code class=\"language-text\">abstract</code></strong> 메서드와는 다르다</em></p>\n</li>\n<li>\n<p>캡슐화</p>\n<p>코드를 재수정 없이 재활용하는 것. 즉, 프로그램 코드에서 변수와 함수를 재활용하기에는 분산되어 있기 때문에 재활용이 어려웠으나 캡슐화를 통해 <strong>관련된 기능과 특성을 한 곳에 모으고 분류하여 재활용을 원할하게 하는 방법</strong>이다.</p>\n<p>객체지향 관점에서는 기능과 특성의 모음을 <strong>클래스</strong>라는 <strong>캡슐</strong>에 분류해서 넣는것이 캡슐화다. 객체가 맡은 역할을 수행하기 위한 하나의 목적을 한 곳으로 모은다.</p>\n</li>\n<li>\n<p>상속</p>\n<p><strong>부모클래스</strong>의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 <strong>자식클래스</strong>에서 해당 기능만 다시 <strong>수정(정의)</strong> 하여 사용할 수 있게 하는 것이다.</p>\n<p><em>다중상속은 <strong>지양 또는, 불가능</strong> (클래스의 상속 관계에서 혼란을 줄 수 있기 때문에 상속은 반드시 하나만 가능하고 필요에 따라 인터페이스를 사용할 수 있게 함.)</em></p>\n<p><em>절차 지향 프로그래밍에서도 <strong>라이브러리</strong>를 통해서 다른 코드를 가져와 사용할 수 있지만 내 의도에 맞게 수정하게되면 <strong>다른 라이브러리</strong>가 되어 버전에 따라 동작하지 않을 수 있고 불필요한 코드의 수정작업을 해야함. 이런 문제를 해결하기 위해 <strong>상속</strong>이라는 것을 도입하였다.</em></p>\n</li>\n<li>\n<p>다형성</p>\n<p>하나의 <strong>변수명, 함수명</strong> 등이 상황에 따라 <strong>다른 의미로 해석</strong>될 수 있는 것.</p>\n<p>즉, <code class=\"language-text\">오버라이딩(Overriding)</code>, <code class=\"language-text\">오버로딩(Overloading)</code>이 가능하다는 얘기다.</p>\n<p><span class=\"em red\">오버라이딩 (Overriding)</span></p>\n<p>부모클래스의 메서드와 <strong>같은 이름, 매개변수</strong>를 재정의 하는 것이다.</p>\n<p><span class=\"em red\">오버로딩 (Overloading)</span></p>\n<p>같은 이름의 함수를 <strong>여러개 정의</strong>하고, <strong>매개변수의 타입과 개수를 다르게 하여</strong> 매개변수에 따라 다르게 호출할 수 있게 하는 것이다.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"getter-setter는-뭐지\" style=\"position:relative;\"><a href=\"#getter-setter%EB%8A%94-%EB%AD%90%EC%A7%80\" aria-label=\"getter setter는 뭐지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Getter, Setter는 뭐지?</h2>\n<p>멤버변수에 직접접근하지 못하게 <code class=\"language-text\">private</code>으로 접근지정자를 설정하고 <code class=\"language-text\">public</code>으로 <strong>getter, setter</strong> 메서드를 만드는 것이 일반적이다.</p>\n<p><strong>getter, setter</strong>를 사용하면 메서드를 통해서 접근하기 때문에, 메서드 안에서 매개변수같이 <strong>어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절</strong>한다.</p>\n<hr>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://frontierdev.tistory.com/93\">캡슐화와 정보은닉</a></li>\n</ul>","fields":{"slug":"/typescript/typescript_solid_1/"},"frontmatter":{"title":"solid하게 SOLID (1)","series_num":1,"date":"Sep 18. 2020","tags":["Typescript","OOP","SOLID","객체지향"]},"headings":[{"value":"OOP 란?","depth":2,"id":"oop-란"},{"value":"OOP 가 뭐길래?","depth":3,"id":"oop-가-뭐길래"},{"value":"왜 좋은데?","depth":3,"id":"왜-좋은데"},{"value":"좋은 점만 있을까?","depth":3,"id":"좋은-점만-있을까"},{"value":"핵심 키워드","depth":3,"id":"핵심-키워드"},{"value":"Getter, Setter는 뭐지?","depth":2,"id":"getter-setter는-뭐지"},{"value":"Reference","depth":2,"id":"reference"}]},"related":{"nodes":[{"fields":{"slug":"/typescript/about_enum/"},"frontmatter":{"title":"Enum","date":"Oct 28. 2020"}},{"fields":{"slug":"/typescript/about_closure/"},"frontmatter":{"title":"Closure와 Private","date":"Oct 24. 2020"}},{"fields":{"slug":"/typescript/about_typescript_4_1/"},"frontmatter":{"title":"Typescript 4.1","date":"Dec 12. 2020"}},{"fields":{"slug":"/typescript/typescript_solid_2/"},"frontmatter":{"title":"solid하게 SOLID (2)","date":"Sep 19. 2020"}}]}},"pageContext":{"id":"50684170-013f-52f1-87fa-b247c01d6567","slug":"/typescript/typescript_solid_1/","series_name":"SOLID 이론","category":"Typescript","previous":{"fields":{"slug":"/aws/about_presigned_url/"},"frontmatter":{"title":"파일에 접근제한 부여하기 - Presigned URL"}},"next":{"fields":{"slug":"/typescript/typescript_solid_2/"},"frontmatter":{"title":"solid하게 SOLID (2)"}}}},"staticQueryHashes":["1069093791","1381152472","1821008744","278901532","3528274121"]}